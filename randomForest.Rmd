---
title: "exercise_RF"
author: "Michael Thiel"
date: "October 14, 2016"
output:
  html_document: default
  word_document: default
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```
```{r knitr, echo=FALSE}
library(knitr)
```

# Land use mapping in West Africa with multi-temporal satellite data (RapidEye)
A practical Guide

Prepared by: Dr. Gerald Forkuor (University of Wuerzburg, now UNU Accra)

modified by: Dr. Michael Thiel (University of Wuerzburg)

# Part 1: Importing co-registered Images into R
1. Start R or RStudio
2. Install these packages: raster, rgdal, maptools, sp, randomForest, rpart and stringr. You can install a package in two ways. First, from the "Tools" menu, select "Install packages". Type in the packages you'd like to install. We now choose the second way where you can type "install.packages("name of package")" at the R command prompt and press "Enter" on your keyboard. E.g. install.packages("randomForest"). Make sure that the name of the package is in quotes.
```{r install the packages}
#install.packages("raster", repos="http://cran.rstudio.com/")
#install.packages("rgdal", repos="http://cran.rstudio.com/")
#install.packages("maptools", repos="http://cran.rstudio.com/")
#install.packages("sp", repos="http://cran.rstudio.com/")
#install.packages("randomForest", repos="http://cran.rstudio.com/")
#install.packages("rpart", repos="http://cran.rstudio.com/")
#install.packages("stringr", repos="http://cran.rstudio.com/")
```
3. Next, load the libraries of the packages. By loading the libraries, you'll be able to use the respective functions that are associated with the packages. To load a library, type:
a. E.g. library(rgdal) at the command prompt. No quotes this time!
```{r load packages, echo=FALSE}
library(knitr)
```
```{r load packages ii}
library(raster)
library(rgdal)
library(maptools)
library(sp)
library(randomForest)
library(rpart)
library(stringr)
```
4. Set your working directories - input and output paths. Normally, the input path (indir) will be where your images are, and the output (outdir) is where you would like to store processed results. The function "setwd" is used to set your working directory. For example, you can type the following at the R command prompt:
```{r set working directories}
indir <- "/Users/mit01wd/Documents/04_CapacityBuilding/R_courses/02_data/R/Images/" 
setwd(indir)
outdir <- "/Users/mit01wd/Documents/04_CapacityBuilding/R_courses/02_data/R/R-files/" 
```
6. In order to be sure that your images are indeed in the specified input directory, we'll use the "list.files" fuction to view the files in the working directory. Type the following at the command prompt and press "enter" on the keyboard:
```{r list the files in the working directory}
list.files(getwd()) 
```
The "getwd()" function here returns the working directory to the "list.files" function. Thus we get a list of all files in the working directory. 

Do you see the files in your input directory? If not, you might have specified the wrong directory, check this out! You can easily overwrite the working directory (indor) by the correct path.

7. Since our images are stacked images (multiple bands), we'll use the "stack" function from the "raster" package to import them into R. For example:
```{r load images}
juneimage <- stack(str_c(indir, "June")) 
octimage <- stack(str_c(indir, "October"))
```
with "June" and "October" being the names of the images files. Change these names if this is not true. Here, it is assumed that "June" and "October" are ENVI images that are in the default directory, "indir". We have checked this  before with "list.files"

8. Now "juneimage" and "octimage" are your June and October RE images in R. You can view the properties of each by just typing the name at the command prompt and pressing "enter". For example, the description below is what you should get for "juneimage".
```{r show properties of June image}
juneimage
```
Note that R recognizes that the image is stacked, has 5 layers/bands and has a coordinate reference of UTM Zone 30N. It also provides information on the min and max value per band.

We can even display the images by using the "plotRGB" function to see if they show exactly the area we like to analyse.
```{r plot juneimage}
plotRGB(juneimage, 5, 3, 2, stretch="lin")
```

Here we display the bands nir, red and green by applying the nir band to the red channel, the red band to the green channel and the the green band to the blue channel, a so called false color composit. Look at the October image as well. Do you see any difference??

Now plot the same image with another stretch function. Do you see the difference?
```{r plot juneimage again}
plotRGB(juneimage, 5, 3, 2, stretch="hist")
```

\pagebreak

## Part 2: Spectral Bands and Indices
The images we have currently are stacked. We can work with these in R. However, we'd like to assign each band to a filename. This will make the calculation of spectral indices much easier! Apart from the original five RE spectral bands, we will be calculating 7 other indices from these five. These are:

* Difference between Near Infrared (NIR) and Red bands
* Difference between NIR and Green bands
* Difference between NIR and Rededge bands
* Ratio of NIR and Green bands
* Ratio of NIR and Rededge bands
* Ratio of NIR and Red bands
* NDVI of NIR and Red bands (traditional NDVI)
* NDVI of NIR and Rededge bands

9. We'll first of all use the "raster" function in the raster package to assign each spectral band to a specific name. We know that band 1 = Blue; 2 = Green; 3 =Red; 4 = Rededge and 5 = NIR. The following code will do exactly this! We'll use the June images as an example.
``` {r write bands into single rasters}
blue <- raster(juneimage, 1)
green <- raster(juneimage, 2)
red <- raster(juneimage, 3)
rededge <- raster(juneimage, 4)
nir <- raster(juneimage, 5)
```
Now, preview one of these images by just typing its name at the command prompt. Look at its properties. E.g., the properties of "blue" should look similar to what's below. Note that these images, blue, green, etc. are all in memory! They have not been written to file yet! 
```{r preview single bands}
blue
plot(blue)
```

Note that R correctly identifies it as a single band image!

10. We'll now write all the bands to disk, i.e. our output folder using the writeRaster function.
```{r write out the rasters}
writeRaster(blue, filename=str_c(outdir, "Blue_Jn", ".tif"), format="GTiff", overwrite=T)
```
The command above will write the blue band as a Geotiff file and store it in the output director specified above. Repead this step now for the other bands as well. Take care to change the names of the bands (blue, green, red, rededge, nir) in the command above at both places. The function "str\_c" from the "stringr" package concatenates strings. Thus, in the syntax above, the part "str\_c(outdir, "Blue\_Jn", ".tif")" will do something like this as the filename: "C:/RSdata/R-files/Blue\_Jn.tif"

The "\_Jn" at the end of the file name is meant to separate the bands of one month from the other. You can choose to completely automate this so that you don't have to write this at the end of each file. For instance, you can introduce a variable called "month" and assign the name of the month to it. The code will then look like this:
```{r alternative for writing out the data}
month <- "Jn"
writeRaster(blue, filename=str_c(outdir, "Blue_", month, ".tif"), 
            format="GTiff", overwrite=T)
```

You could also make it much better, by avoiding to write the name of the band (Blue) in the syntax. You can choose to run this in a "For Loop". The code below will assign band names to the raster stack, automatically extract these names and append the name of the month to each band.
```{r all in one alternative}
month <- "Jn"
bandnames <- c("blue", "green", "red", "rededge", "nir")
names(juneimage) <- bandnames
for (i in 1:nlayers(juneimage)) {
writeRaster((raster(juneimage, i)), filename=str_c(outdir,names(juneimage)[i],
                              "_", month, ".tif"), format="GTiff", overwrite=T)
}
```

11. We'll now derive the indices mentioned above from the original 5 RE bands. Before we do this, however, we will define three functions using the "function" function. This will be required when we use the "overlay" function in the raster package. The first function will calculate NDVI based on two input bands (x, y). The second and third are for ratios and differences respectively.

```{r define functions}
fun_nd <- function(x, y){return((y-x)/(y+x))}
fun_rt <- function(x, y){return(x/y)}
fun_df <- function(x, y){return(x-y)}
```

12. Next, we'll use the "overlay" function to calculate the indices. The code below calculates the NDVI based on the NIR and rededge bands. Overlay calculates the NDVI based on the function provided, and writes the file to our output directory! 
```{r calculate indeces}
overlay(rededge, nir, fun=fun_nd, filename=str_c(outdir, "ND_nir_re_", month, ".tif"), 
        format="GTiff", overwrite=T)
```

Try and write similar for the real NDVI and the other two indices above, giving each a meaningful name! 
Here is the NDVI:
```{r calc NDVI}
overlay(red, nir, fun=fun_nd, filename=str_c(outdir, "ND_nir_red_", month, ".tif"), 
        format="GTiff", overwrite=T)
```

And here now some meaningful indeces using the other functions and layers as well, starting with the so called simple ratio (SR):
```{r calc all others}
overlay(red, nir, fun=fun_rt, filename=str_c(outdir, "Rt_nir_red_", month, ".tif"), 
        format="GTiff", overwrite=T)
overlay(green, nir, fun=fun_rt, filename=str_c(outdir, "Rt_nir_green_", month, ".tif"), 
        format="GTiff", overwrite=T)
overlay(rededge, nir, fun=fun_rt, filename=str_c(outdir, "Rt_nir_re_", month, ".tif"), 
        format="GTiff", overwrite=T)
overlay(red, nir, fun=fun_df, filename=str_c(outdir, "Df_nir_red_", month, ".tif"), 
        format="GTiff", overwrite=T)
overlay(rededge, nir, fun=fun_df, filename=str_c(outdir, "Df_nir_re_", month, ".tif"), 
        format="GTiff", overwrite=T)
overlay(green, nir, fun=fun_df, filename=str_c(outdir, "Df_nir_green_", month, ".tif"), 
        format="GTiff", overwrite=T)
```
13. Now we have completed writing all the bands and indices of the June image into our output folder as Geotiffs. In your folder, there should be 13 images, each ending with "\_Jn". Repeat steps 9 to 12 and write all the bands and indices for the October image as well, each ending with "\_Oc". After this, you should have a total of 26 images in your folder.


```{r doing it all for October}
# 9
blue <- raster(octimage, 1)
green <- raster(octimage, 2)
red <- raster(octimage, 3)
rededge <- raster(octimage, 4)
nir <- raster(octimage, 5)

# 10
month <- "Oc"
names(octimage) <- bandnames
for (i in 1:nlayers(octimage)) {
writeRaster((raster(octimage, i)), filename=str_c(outdir,names(octimage)[i],
                              "_", month, ".tif"), format="GTiff", overwrite=T)
}

# 11 does not to be executed again

# 12
overlay(rededge, nir, fun=fun_nd, filename=str_c(outdir, "ND_nir_re_", month, ".tif"), 
        format="GTiff", overwrite=T)
overlay(red, nir, fun=fun_nd, filename=str_c(outdir, "ND_nir_red_", month, ".tif"), 
        format="GTiff", overwrite=T)
overlay(red, nir, fun=fun_rt, filename=str_c(outdir, "Rt_nir_red_", month, ".tif"), 
        format="GTiff", overwrite=T)
overlay(green, nir, fun=fun_rt, filename=str_c(outdir, "Rt_nir_green_", month, ".tif"), 
        format="GTiff", overwrite=T)
overlay(rededge, nir, fun=fun_rt, filename=str_c(outdir, "Rt_nir_re_", month, ".tif"), 
        format="GTiff", overwrite=T)
overlay(red, nir, fun=fun_df, filename=str_c(outdir, "Df_nir_red_", month, ".tif"), 
        format="GTiff", overwrite=T)
overlay(rededge, nir, fun=fun_df, filename=str_c(outdir, "Df_nir_re_", month, ".tif"), 
        format="GTiff", overwrite=T)
overlay(green, nir, fun=fun_df, filename=str_c(outdir, "Df_nir_green_", month, ".tif"), 
        format="GTiff", overwrite=T)
```

14. At this point we will try to create one big stack of all the twenty-four images we have in the output folder. We'll use the "stack" and "list.files" functions to do this. First, we'll use list.files to preview all our files in the output folder.
```{r list produced files}
list.files(outdir) ## All files will be shown
```
In the code below, R will look through outdir and stack all files ending with ".tif".
```{r stack them all}
allimages <- stack(list.files(outdir, pattern=".tif", all.files=T, full.names=T))
```

A preview of "allimages" should look similar to what's below. The rasterstack should have 26 layers. 
```{r proberties of allimages, echo=FALSE}
allimages
```

\pagebreak

## Part 3: Preparing Data for Random Forest
We have now prepared the satellite data to be used in classification. However, RF needs two important input files - (1) training values and (2) response.
Training Values: Training values are required by RF to construct decision trees. These training values can be derived based on a shapefile of training areas which were mapped on the field or based on interpretation of aerial photograph. Training areas represent the various land use/land cover classes in the area of interest. Each polygon in this shapefile should have a unique code that specifies the land use/land cover that it represents. For example, all polygons representing grasslands may have a unique ID of "1", while "2" may represent forest. These IDs should be recorded in a column in the shapefile's attribute table.
Response: Response provides information about class membership in the classification scheme. It associates the training values with the class it represents. After classification, the classified image is labeled with unique values in the response. The response is compiled from the unique ID code in the attribute table of the training areas shapefile.
A shapefile of training areas have been provided in the working directory ("training_areas.shp"). First, we will import this shapefile into R. Based on these areas, we'll then extract the values of our 26 band raster stack earlier prepared. Thus, for each band in the raster stack, a value will be extracted for each pixel that falls within a training area. In figure below, assume that the red and blue polygons are training areas representing two land use/land cover types. Thus, for each band in our raster stack, all pixels that fall in these polygons will be extracted as training values.
```{r plotting map of image and polygons, echo=FALSE}
#find our how to plot them
#Figure 3. An example of a raster file with cell ID labels and training areas superimposed.
```

Importing the Shapefile into R
We'll now specify the path to the shapefile and use the "readShapePoly" function to import the shapefile.
```{r reading in the shape file}
shapefile <- "C:/thiel/uni/07_lehre/02_WASCAL/CC-LU/R/Shapefiles/training_areas.shp" 
## as the Path to shapefile
trainingshp <- readOGR(shapefile) ## Read in the shapefile
```
Have now a look at the properties of the loaded shapefile. 
```{r looking at shapefile}
trainingshp
```
The code below specifies the name of the column in the attribute table that stores the unique class IDs, as you may have identified in the properties of the shapefile. You can preview the shapefile in QGIS and make sure the correct name has been specified.
````{r where is the unique identifier}
nameofTrainingClassColumn <- "Id"
```
In generating the training values, you can set the maximum number of samples/pixels for each classes. Here, a maximum of 500 is given.
```{r maximum sample number}
max_nr_samplesperclass <- 500
```
This code creates a vector of the unique class IDs in the attribute table of your shapefile. It will later be used in a "for"-loop to generate samples/training values for each class.
```{r list of unique ID}
classes<-as.numeric(sort(unique(trainingshp[[nameofTrainingClassColumn]])))
```
To check and control now the meaning behind the class IDs you can do the following:
```{r checking class IDs}
class_names <- vector(length = length(classes))
for (i in classes){
  class_names[i] <- as.character(unique(trainingshp$LULC[which(trainingshp$Id == classes[i])]))
  }
cbind(classes, class_names)
```
There you first create an empty vector which contains the same numbrer of elements than the classes vector. In the following for-loop you apply for each given ID the specific class name to the previous created vector class_names. Finally you show the combination of these two vectors to get a better overview.

A raster file has cell/pixel IDs. This numbering starts from the top left corner and ends at the bottom right corner (see Figure above). Note that these numbers are different from the cell values! In order to extract the values of the pixels that fall within each of our training areas, we'll first extract the IDs of these pixels. The function "cellFromPolygon", will allow us to extract cell IDs of a raster based on a polygon dataset. So, we'll run this command with our 26 band rasterstack and the shapefile we just imported into R.
```{r extract cell ids}
cellidlist<-cellFromPolygon(allimages, trainingshp)
```
For a particular class, the list of cell IDs (as in cellidlist) may be more than the specified maximum number of training samples (see above). For example, the number of cells/pixels that fall in polygons representing grasslands may be more than 500. In such cases, a selection has to be made to meet the criteria specified earlier. For this purpose, an empty vector (cellidselect) is defined below to store the exact number of cell IDs per class. Another empty vector (response) is also created to store the unique class IDs and the total number of cell IDs that correspond to it.
```{r prepare cell ids and response}
cellidselect<-vector()
response<-vector()
```
The "for"-loop below fills the empty vectors defined above with the requisite information. First of all, the loop is run for all unique classes/IDs in the variable called "classes" (defined above). An explanation of each line is given.
```{r first line}
#for(c in classes) { ## c is a counter for the unique IDs in "classes"
```
The code below will "open" the attribute table of the shapefile and look in the column that has the unique class IDs. R will, then, extract all the polygons that belongs to a particular class (here denoted by "c"). Note that this is done for one class at a time, since it is in a "For Loop".
```{r second line}
#polys<-which(trainingshp@data[[nameofTrainingClassColumn]]==c)
```
Next, R will look into the "cellidlist" earlier created and extract all the cell IDs that belong to the polygons extracted in Line 1 above. Note that "recursive=True" means that R will recursively go through the "cellidlist" and combine all cell IDs that belong to the polygons in "poly".
```{r third line}
#classids<-c(cellidlist[polys], recursive=TRUE)
```
At this point, R will compare the number of elements in "classids" as determined in line 2 with the maximum number of samples earlier specified. If there are more than we specified, R will randomly select the number required. Else, it will maintain the total number.
```{r forth line}
#if(length(classids)>max_nr_samplesperclass) classids<-sample(classids,max_nr_samplesperclass)
```
Here, "classids" (which are actually a list of cell IDs that fall within a certain land use/land cover type) are added to the empty vector created above.
```{r fifth line}
#cellidselect<-c(cellidselect, classids)
```
In the code below, "rep" stands for replicate. R will first calculate the length of the "classids" list. This is simply the number of elements or cell IDs. So what the code does is that it will replicate the counter "c" (which actually indicates a specific class ID) a number of times equal to the length of "classids". For example, if the first class ID is 1 (i.e. c=1) and there are 500 cells/pixels that fall within the training area of this class (i.e. length(classids) = 500), R will replicate "1" 500 times. It will then add that to the empty "response" vector earlier created.
```{r end it up}
#response<-c(response, rep(c, length(classids)))
#} ### End of For Loop
```
Here now, all the steps in a overview without disturbances: 
```{r for loop}
for(c in classes) {
  polys<-which(trainingshp@data[[nameofTrainingClassColumn]]==c)
  classids<-c(cellidlist[polys], recursive=TRUE)
  if(length(classids)>max_nr_samplesperclass) 
    classids<-sample(classids,max_nr_samplesperclass)
  cellidselect<-c(cellidselect, classids)
  response<-c(response, rep(c, length(classids)))
} 
```
Now, we will use the "cellidselect" to extract the actual values of the cells. Since we have a 24 band raster stack, we are supposed to get 24 values for each cell ID. The code below does that, and then converts the resulting table into a data frame. We'll also convert the "response" from a numeric data type to a factor data type. For classification, random forest requires a factor response.
```{r extract cell values}
trainvals <- as.data.frame(allimages[cellidselect])
response <- as.factor(response)
```
Now, we can go on further with Part 4 where the RandomForest classification will be done. 

\pagebreak

## Part 4: Running Random Forest
All is now set to run random forest! In the code below, 500 trees will be constructed. "localImp" is a variable importance measure which will tell us which of the variables/predictors/bands that was/were important in class separation (see randomforest manual for more information). After randomForest runs, type "rf" at the command prompt to view the results. RF gives you the number of variables tried at each split and the OOB estimate of error rate. A confusion matrix is presented as well. RF also provides the opportunity for you to supply an independent dataset for testing the accuracy of the predictions. In such a case, you'd have to provide two sets of data (one set for training, i.e. training values and response, and the other set for testing, i.e. testing values and response). See RF manual for more details.
```{r run random forest}
rf <- randomForest(x=trainvals, y=response, ntree=500, localImp=T, 
                   proximity=T, keep.forest=T)
```
You could change the number of trees grown to say 1000, and see if there's any change in the OOB estimate or the confusion matrix. To see the confusion matrix just use:
```{r confusion matrix}
rf$confusion
```
Please be careful using this confusion matrix as the final accuracy assessment result for your classification. If you're using a totally undependent data set for doint the accuracy assessment you will most often get a totally different result. So, please use such an undependent data set.

If the confusion matrix looks OK for you, we'll go on and look at how the variables/bands faired. We'll use the "varImpPlot" function to get a plot/graph of each variable and how important it was in the construction of the trees.
```{r variable importance}
varImpPlot(rf, type=1)## A plot of the Mean Decrease in Accuracy
varImpPlot(rf, type=2)## A plot of the Mean Decrease in Gini
varImpPlot(rf) ## put both together in one plot
```

If this is useful information for you, you could write the results to file (e.g. text file). The code below does just that!
```{r write out the results of varible importance}
varImp <- as.data.frame(importance(rf))
write.table(varImp, file=str_c(outdir, "importance", ".txt"), sep=";", dec=".")
```
Finally, we'll use the RF object that has been calculated (rf) and our 26 band raster stack to create a classification map. The "predict" function in the raster package will be used for this. "predict" creates a raster object with predictions from a fitted model object. In this case, our output from RF is the fitted model object.
```{r predict}
predict(allimages, rf, filename=str_c(outdir, "Classify", ".tif"), progress='text', 
        format='GTiff', datatype='INT1U', type='response', overwrite=TRUE)
```
When "predict" has finished calculating the classification map, open QGIS and view the results.
